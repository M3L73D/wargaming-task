# Тестовое задание на позицию Junior Programmer в компании Wargaming Санкт-Петербург

## Задание 1

<details>
  <summary>Условие задания</summary>

  На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.

  Python example:
  ```python
  def isEven(value):
     return value % 2 == 0
  ```
</details>

**Python:**

Наша задача максимально эффективно определить четность числа. Самый простой способ - это поделить число на 2 и посмотреть на остаток. На Python это выглядит так:
```python
def is_even(num):
   return num % 2 == 0
```
Второй способ не менее очевидный. Известно, что процессор работает с числами в двоичном представлении. Четные числа в таком представлении всегда заканчиваются на 0. Будет иметь смысл следующее решение:
```python
def is_even(num):
   return num & 1 == 0
```
Что с эффективностью? Неизвестно, сколько операций потребуется процессору для того, чтобы вернуть остаток от деления числа на 2, однако для совершения операции И ему потребуется всего один такт.

Подтвердим это замерами на массиве из 10000000 чисел:

```
%: 2.7199012920000003s
&: 2.36535246s
```

Делаем вывод, что при использовании оператора & скорость выполнения выше, хоть и ненамного.

**Исходный код:** [ссылка](https://github.com/M3L73D/wargaming-task/blob/main/01.py)

## Задание 2

<details>
  <summary>Условие задания</summary>

  На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.
</details>

**Python:**

Первый класс представляет собой простую реализацию массива FIFO без возможности перезаписывать существующие данные. Попытка записать данные в переполненный или прочитать данные из пустого буфера вызовет ошибку. В качестве данных буфера могут выступать любые элементы.

Второй класс представляет собой кольцевой буфер с возможностью перезаписи существующих данных. При инициализации создается массив размера `capacity` из `None` элементов. Это значит, что впоследствии мы не сможем использовать `None` в качестве элемента буфера. Попытка прочитать данные из пустого буфера вызовет ошибку.

**Исходный код:**
1. Простая реализация: [ссылка](https://github.com/M3L73D/wargaming-task/blob/main/02_01.py)
2. Сложная реализация: [ссылка](https://github.com/M3L73D/wargaming-task/blob/main/02_02.py)

## Задание 3

<details>
  <summary>Условие задания</summary>

  На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.
</details>

**Python:**

Python, как и многие другие языки высокого уровня, предоставляет возможность сортировки "из коробки" с помощью sorted(). В настоящее время стандартным алгоритмом сортировки в Python является Timsort. Основная идея алгоритма в том, что сортируемые массивы данных как правило содержат упорядоченные подмассивы. Потому, на таких данных Timsort работает намного быстрее других алгоритмов сортировки.

Основная идея данного решения в том, что, как правило, все необходимые функции уже встроены или представлены в стандартных библиотеках языка. Как правило, эти функции протестированы и оптимизированы разработчиками и будут работать стабильнее и быстрее, чем ваша собственная реализация. Для сравнения мы используем встроенную в Python функцию сортировки и нашу собственную реализацию Quicksort на массиве из 10000 чисел.

Результаты замеров:
```
quicksort: 0.024071323999999998s
sorted: 0.002125191999999991s
```

При повторных замерах мы видим разницу во времени выполнения в 10-20 раз. Стоит отметить, что встроенный алгоритм Timsort реализован на языке C, что также играет немаловажную роль в скорости его выполнения.

Основным недостатком Timsort является сложность его реализации, особенно в сравнении с Quicksort. Достоинствами является его возможность предсказуемо работать за O(nlog2n), независимо от структуры входного массива, и скорость выполнения на массивах, близких к отсортированным, что делает его хорошим выбором при работе с реальными данными.


**Исходный код:** [ссылка](https://github.com/M3L73D/wargaming-task/blob/main/03.py)
